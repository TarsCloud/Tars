/**
 * Tencent is pleased to support the open source community by making Tars available.
 *
 * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
 *
 * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * https://opensource.org/licenses/BSD-3-Clause
 *
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.0.1.
// **********************************************************************

package com.qq.tars.support.stat.prx;

import com.qq.tars.protocol.util.*;
import com.qq.tars.protocol.annotation.*;
import com.qq.tars.protocol.tars.*;
import com.qq.tars.protocol.tars.annotation.*;

@TarsStruct
public class StatMicMsgBody {

	@TarsStructProperty(order = 0, isRequire = true)
	public int count = 0;
	@TarsStructProperty(order = 1, isRequire = true)
	public int timeoutCount = 0;
	@TarsStructProperty(order = 2, isRequire = true)
	public int execCount = 0;
	@TarsStructProperty(order = 3, isRequire = true)
	public java.util.Map<java.lang.Integer, java.lang.Integer> intervalCount = null;
	@TarsStructProperty(order = 4, isRequire = true)
	public long totalRspTime = 0L;
	@TarsStructProperty(order = 5, isRequire = true)
	public int maxRspTime = 0;
	@TarsStructProperty(order = 6, isRequire = true)
	public int minRspTime = 0;

	public int getCount() {
		return count;
	}

	public void setCount(int count) {
		this.count = count;
	}

	public int getTimeoutCount() {
		return timeoutCount;
	}

	public void setTimeoutCount(int timeoutCount) {
		this.timeoutCount = timeoutCount;
	}

	public int getExecCount() {
		return execCount;
	}

	public void setExecCount(int execCount) {
		this.execCount = execCount;
	}

	public java.util.Map<java.lang.Integer, java.lang.Integer> getIntervalCount() {
		return intervalCount;
	}

	public void setIntervalCount(java.util.Map<java.lang.Integer, java.lang.Integer> intervalCount) {
		this.intervalCount = intervalCount;
	}

	public long getTotalRspTime() {
		return totalRspTime;
	}

	public void setTotalRspTime(long totalRspTime) {
		this.totalRspTime = totalRspTime;
	}

	public int getMaxRspTime() {
		return maxRspTime;
	}

	public void setMaxRspTime(int maxRspTime) {
		this.maxRspTime = maxRspTime;
	}

	public int getMinRspTime() {
		return minRspTime;
	}

	public void setMinRspTime(int minRspTime) {
		this.minRspTime = minRspTime;
	}

	public StatMicMsgBody() {
	}

	public StatMicMsgBody(int count, int timeoutCount, int execCount, java.util.Map<java.lang.Integer, java.lang.Integer> intervalCount, long totalRspTime, int maxRspTime, int minRspTime) {
		this.count = count;
		this.timeoutCount = timeoutCount;
		this.execCount = execCount;
		this.intervalCount = intervalCount;
		this.totalRspTime = totalRspTime;
		this.maxRspTime = maxRspTime;
		this.minRspTime = minRspTime;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + TarsUtil.hashCode(count);
		result = prime * result + TarsUtil.hashCode(timeoutCount);
		result = prime * result + TarsUtil.hashCode(execCount);
		result = prime * result + TarsUtil.hashCode(intervalCount);
		result = prime * result + TarsUtil.hashCode(totalRspTime);
		result = prime * result + TarsUtil.hashCode(maxRspTime);
		result = prime * result + TarsUtil.hashCode(minRspTime);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (!(obj instanceof StatMicMsgBody)) {
			return false;
		}
		StatMicMsgBody other = (StatMicMsgBody) obj;
		return (
			TarsUtil.equals(count, other.count) &&
			TarsUtil.equals(timeoutCount, other.timeoutCount) &&
			TarsUtil.equals(execCount, other.execCount) &&
			TarsUtil.equals(intervalCount, other.intervalCount) &&
			TarsUtil.equals(totalRspTime, other.totalRspTime) &&
			TarsUtil.equals(maxRspTime, other.maxRspTime) &&
			TarsUtil.equals(minRspTime, other.minRspTime) 
		);
	}

	public void writeTo(TarsOutputStream _os) {
		_os.write(count, 0);
		_os.write(timeoutCount, 1);
		_os.write(execCount, 2);
		if (null != intervalCount) {
			_os.write(intervalCount, 3);
		}
		_os.write(totalRspTime, 4);
		_os.write(maxRspTime, 5);
		_os.write(minRspTime, 6);
	}

	public void readFrom(TarsInputStream _is) {
		this.count = _is.read(count, 0, true);
		this.timeoutCount = _is.read(timeoutCount, 1, true);
		this.execCount = _is.read(execCount, 2, true);
		this.intervalCount = (java.util.Map<java.lang.Integer, java.lang.Integer>) _is.read(intervalCount, 3, true);
		this.totalRspTime = _is.read(totalRspTime, 4, true);
		this.maxRspTime = _is.read(maxRspTime, 5, true);
		this.minRspTime = _is.read(minRspTime, 6, true);
	}

}

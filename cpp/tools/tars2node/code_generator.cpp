/**
 * Tencent is pleased to support the open source community by making Tars available.
 *
 * Copyright (C) 2016THL A29 Limited, a Tencent company. All rights reserved.
 *
 * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except 
 * in compliance with the License. You may obtain a copy of the License at
 *
 * https://opensource.org/licenses/BSD-3-Clause
 *
 * Unless required by applicable law or agreed to in writing, software distributed 
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR 
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the 
 * specific language governing permissions and limitations under the License.
 */

#include "code_generator.h"

string CodeGenerator::printHeaderRemark(const string &sTypeName)
{
    ostringstream s;
    s << "// **********************************************************************" << endl;
    s << "// Parsed By " << IDL_NAMESPACE_STR << "Parser(" << PARSER_VERSION << "), Generated By " << EXECUTE_FILENAME << "(" << GENERATOR_VERSION << ")" << endl;
    s << "// " << IDL_NAMESPACE_STR << "Parser Maintained By <WSRD> and " << EXECUTE_FILENAME << " Maintained By <superzheng>" << endl;
    s << "// Generated from \"" << TC_File::extractFileName(_sIdlFile) << "\" by " << 
            (_bEntry ? sTypeName : (_bMinimalMembers ? "Minimal" : "Relation")) << " Mode" << endl;
    s << "// **********************************************************************" << endl;
    s << endl;

    return s.str();
}

void CodeGenerator::createFile(const string &file, const bool bEntry)
{
    _sIdlFile = getRealFileInfo(file);
    _bEntry = bEntry;

    g_parse->parse(_sIdlFile);

    vector<ContextPtr> contexts = g_parse->getContexts();

    for(size_t i = 0; i < contexts.size(); i++)
    {
        if (_sIdlFile == contexts[i]->getFileName())
        {
            scan(_sIdlFile, true);                                  //分析枚举值、结构体所在的文件

            if (!_bClient && !_bServer) 
            {
                generateJS(contexts[i]);                            //生成当前文件的编解码文件
                if(_bDTS) generateDTS(contexts[i]);                 //生成 typescript 描述文件
            }

            if (_bClient) 
            {
                if(!generateJSProxy(contexts[i])) return;           //生成当前文件的客户端代理类文件
                if(_bDTS) generateDTSProxy(contexts[i]);            //生成客户端 typescript 描述文件
            }

            if (_bServer)
            {
                if(!generateJSServer(contexts[i])) return;           //生成当前文件的服务端代理类文件
                if(_bDTS) generateDTSServer(contexts[i]);            //生成服务端 typescript 描述文件

                generateJSServerImp(contexts[i]);                    //生成当前文件的服务端实现类文件
            }

            vector<string> files = contexts[i]->getIncludes();
            for (size_t ii = 0; _bRecursive && ii < files.size(); ii++)
            {
                CodeGenerator node;
                node.setRpcPath(_sRpcPath);
                node.setStreamPath(_sStreamPath);
                node.setTargetPath(_sToPath);
                node.setRecursive(_bRecursive);
                node.setUseSpecialPath(_bUseSpecialPath);
                node.setUseStringRepresent(_bUseStringRepresent);
                node.setStringBinaryEncoding(_bStringBinaryEncoding);
                node.setMinimalMembers(_bMinimalMembers);
                node.setDependent(_depMembers);
                node.setEnableDTS(_bDTS);

                node.createFile(files[ii], false);
            }
        }
    }
}